package com.auxiliary.tester;import java.util.ArrayList;import java.util.List;import java.util.Random;import java.util.UUID;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.RecursiveAction;import java.util.concurrent.TimeUnit;public class CompileRecursiveAction extends RecursiveAction {    private List<Pair> list;    private int start;    private int end;    public CompileRecursiveAction(List<Pair> list, int start, int end) {        this.list = list;        this.start = start;        this.end = end;    }    @Override    protected void compute() {        //handle  the task        if (end - start < 10){            geting();        }else{            int middle = (end + start)/2 ;            CompileRecursiveAction t1 = new CompileRecursiveAction(list , start , middle);            CompileRecursiveAction t2 = new CompileRecursiveAction(list , middle-1 , end);            invokeAll(t1 , t2);        }    }    private void geting(){        for (int i=start; i< end ;i++){            list.get(i).setName(UUID.randomUUID().toString());            list.get(i).setSize(new Random().nextInt());        }    }}class Pair{    private String name;    private int size;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getSize() {        return size;    }    public void setSize(int size) {        this.size = size;    }}class RecusiveMain{    public static void main(String[] args) {        ForkJoinPool pool = new ForkJoinPool();        List<Pair> init = init();        CompileRecursiveAction task = new CompileRecursiveAction(init , 0 , init.size()-1);        pool.execute(task);        do {            System.out.printf("mainThread: ThreadCount: %d \n", pool.getActiveThreadCount());            System.out.printf("main:stealCount: %d \n",pool.getStealCount());            System.out.printf("mian:parallesime:%d \n", pool.getParallelism());            try {                TimeUnit.MILLISECONDS.sleep(5);            } catch (Exception e) {                e.printStackTrace();            }        } while (!task.isDone());        pool.shutdown();    }    static List<Pair> init(){        List<Pair> list = new ArrayList<>();        for (int i = 0 ; i < 500 ; i++){            list.add(new Pair());        }        return list;    }}