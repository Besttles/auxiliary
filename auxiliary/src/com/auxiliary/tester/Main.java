package com.auxiliary.tester;public class Main {    public static void main(String[] args) throws InterruptedException {//        CountDownLatch latch = new CountDownLatch(3);//        Thread thread1 = new Thread(() -> {//            try {//                TimeUnit.SECONDS.sleep(5);//                latch.countDown();//                System.out.println("1");//            } catch (InterruptedException e) {//                e.printStackTrace();//            }//        });//        Thread thread2 = new Thread(() -> {//            try {//                TimeUnit.SECONDS.sleep(5);//                latch.countDown();//                System.out.println("2");//            } catch (InterruptedException e) {//                e.printStackTrace();//            }//        });//        Thread thread3 = new Thread(() -> {//            try {//                TimeUnit.SECONDS.sleep(5);//                latch.countDown();//                System.out.println("3");//            } catch (InterruptedException e) {//                e.printStackTrace();//            }//        });////        List<Thread> threads = new ArrayList<Thread>();//        threads.add(thread1);//        threads.add(thread2);//        threads.add(thread3);////        ThreadManagerLatch latch1 = new ThreadManagerLatch("pool",Executors.newFixedThreadPool(3));//        latch1.synLatch(threads , latch).shutdown();//        CountDownLatch latch = new CountDownLatch(3);//        LinkedList<NameCallable> linkedList = new LinkedList<>();//        NameCallable system = new SystemCheckCallable("SYSTEMCHECK" , latch);//        NameCallable system1 = new SystemCheckCallable("Systemin", latch);//        NameCallable system2 = new SystemCheckCallable("SYStemOut" , latch);//        linkedList.add(system);//        linkedList.add(system1);//        linkedList.add(system2);//        ExecutorService pool = Executors.newFixedThreadPool(10);//        CallableManager call = new CallableManager("CallableManage" , pool);////        Map order = call.excute(linkedList, latch).order();////        order.forEach((key , value) -> {//            System.out.println(key);//            System.out.println(value);//        });//        pool.shutdown();////        Map<Thread, StackTraceElement[]> allStackTraces = Thread.getAllStackTraces();////        ThreadGroup group = Thread.currentThread().getThreadGroup();//        ThreadGroup topGroup = group;//// 遍历线程组树，获取根线程组//        while (group != null) {//            topGroup = group;//            group = group.getParent();//        }//// 激活的线程数加倍//        int estimatedSize = topGroup.activeCount() * 2;//        Thread[] slackList = new Thread[estimatedSize];//// 获取根线程组的所有线程//        int actualSize = topGroup.enumerate(slackList);//// copy into a list that is the exact size//        Thread[] list = new Thread[actualSize];//        System.arraycopy(slackList, 0, list, 0, actualSize);//        System.out.println("Thread list size == " + list.length);//        for (Thread thread : list) {//            System.out.println(thread.getName());//        }        int a [] = new int[]{1,3,5,8,9};        int b [] = new int[]{1,2,5,7,9};        merge(a , a.length , b , b.length);        System.out.println(a.toString());    }    public static void merge(int[] nums1, int m, int[] nums2, int n) {        int index1 = m - 1, index2 = n - 1;        int indexMerge = m + n - 1;        while (index1 >= 0 || index2 >= 0) {            if (index1 < 0) {                nums1[indexMerge--] = nums2[index2--];            } else if (index2 < 0) {                nums1[indexMerge--] = nums1[index1--];            } else if (nums1[index1] > nums2[index2]) {                nums1[indexMerge--] = nums1[index1--];            } else {                nums1[indexMerge--] = nums2[index2--];            }        }    }}