package com.auxiliary.manage.thread;import java.util.HashMap;import java.util.LinkedList;import java.util.Map;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Future;/** * @author biwh * 回调函数异步执行，同步返回方法 * */public class CallableManager<V> extends ThreadManager<V>{    public CallableManager(String managerName , ExecutorService excutor) {        super.managerName = managerName;        super.excutor = excutor;    }    private Map<String , Future<V>> futures = new HashMap<>();    @Override    protected void manage() {    }    public CallableManager excute(LinkedList<NameCallable<V>> events , CountDownLatch latch) throws InterruptedException {        events.forEach(event -> {            Future<V> submit = excutor.submit(event);            futures.put(event.getName() , submit);        });        latch.await();        return this;    }    public Map<String , V> order(){        Map<String, V> map = new HashMap<>();        futures.forEach( (key , value) -> {            try {                map.put(key , value.get());            } catch (InterruptedException e) {                e.printStackTrace();            } catch (ExecutionException e) {                e.printStackTrace();            }        });        return map;    }}